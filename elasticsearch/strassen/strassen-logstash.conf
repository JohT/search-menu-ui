input {
    http_poller {
        urls => {
            burgenland => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_1.csv"
                type => "Burgenland"
            }
            kaernten => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_2.csv"
                type => "Kaernten"
            }
            niederoesterreich => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_3.csv"
                type => "Niederoesterreich"
            }
            oberoesterreich => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_4.csv"
                type => "Oberoesterreich"
            }
            salzburg => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_5.csv"
                type => "Salzburg"
            }
            steiermark => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_6.csv"
                type => "Steiermark"
            }
            tirol => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_7.csv"
                type => "Tirol"
            }
            vorarlberg => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_8.csv"
                type => "Vorarlberg"
            }
            wien => {
                url => "http://www.statistik.at/verzeichnis/strassenliste/gemplzstr_9.csv"
                type => "Wien"
            }
        }
        request_timeout => 60
        # Supports "cron", "every", "at" and "in" schedules by rufus scheduler
        schedule => { "in" => "10s"}
        # schedule => { cron => "* * * * * UTC"}
        codec => line { charset => "ISO8859-1" }
        # A hash of request metadata info (timing, response headers, etc.) will be sent here
        metadata_target => "http_metadata"
    }
}
filter {
    csv {
        id => "Strassen"
        columns => [
                "gemeindekennziffer",
                "ort",
                "ortschaftskennziffer",
                "ortschaftsname",
                "strassenkennziffer",
                "strassenname",
                "postleitzahl",
                "gemeindecode"
        ]
        separator => ";"
        skip_empty_columns => true
        skip_empty_rows => true
        add_field => { "bundesland" => "%{[http_metadata][request][type]}" }
        add_field => { "quelle" => "%{[http_metadata][request][url]}" }
        add_field => { "last-modified" => "%{[http_metadata][response_headers][last-modified]}" }
        remove_field => ["ortschaftskennziffer", "strassenkennziffer", "gemeindecode", "message", "@version", "path", "http_metadata"]
        periodic_flush => true
    }
    # skips all header lines characterized by non numeric characters in the first field
    if [gemeindekennziffer]  =~ /\D+/ {
        drop {}
    }
    mutate {
        rename => ["@timestamp", "synchronisierung" ]
        remove_field => ["gemeindekennziffer"]
    }
    date {
        match => ["last-modified", "EEE',' dd MMM yyyy HH:mm:ss 'GMT'"]
        target => "aktualisierung"
        timezone => "Etc/GMT"
        remove_field => ["last-modified"]
    }
    # mutate {
    #     convert => {
    #       "Synchronisierung" => "string"
    #     }
    #   }
    # date {
    #     match => ["Synchronisierung", "ISO8601"]
    #     target => "SynchronisierungNeu"
    #     timezone => "Etc/GMT"
    # }
}
output {
    stdout {
        codec => rubydebug
    }
    elasticsearch {
        action => "index"
        hosts => ["127.0.0.1:9200"]
        index => "strassen"
    }
}
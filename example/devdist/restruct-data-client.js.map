{"mappings":"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","sources":["./src/js/restruct-data-client.js","./node_modules/data-restructor/devdist/datarestructor.js"],"sourcesContent":["/**\n * @file restruct-data-client adapts the search result JSON from the server to the data structure needed by the search UI.\n * @version {@link https://github.com/JohT/search-menu-ui/releases/latest latest version}\n * @author JohT\n */\n\n \"use strict\";\n\nvar module = datarestructorInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction datarestructorInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Adapts the search result JSON from the server to the data structure needed by the search UI.\n * @module restruct\n */\n var restruct = module.exports={}; // Export module for npm...\n restruct.internalCreateIfNotExists = datarestructorInternalCreateIfNotExists;\n \nvar datarestructor = datarestructor || require(\"data-restructor/devdist/datarestructor\"); // supports vanilla js & npm\n\nrestruct.DataConverter = (function () {\n  /**\n   * Provides the data converter for the search. \n   * It uses \"datarestructor\" and acts as a delegating client in between.\n   * @constructs DataConverter\n   */\n  function DataConverter() {\n\n    /**\n     * Creates the data converter function with or without debugMode.\n     * @function\n     * @param {boolean} debugMode \n     * @returns data converter function\n     * @memberof DataConverter#\n     */\n    this.createDataConverter = function(debugMode) {\n      return function(jsonData) {\n        return restructJson(jsonData, debugMode);\n      };\n    };\n\n    /**\n     * @function\n     * @returns {PropertyStructureDescription}\n     * @memberof DataConverter#\n     */\n    this.getDescriptions = function() {\n      return getDescriptions();\n    };\n  }\n\n  function restructJson(jsonData, debugMode) {\n    if (debugMode) {\n      console.log(\"data before it gets restructured:\");\n      console.log(jsonData);\n    }\n    var transform = new datarestructor.Transform(getDescriptions()).setRemoveDuplicationAboveRecursionDepth(0).setMaxRecursionDepth(2);\n    if (debugMode) {\n      transform.enableDebugMode();\n    }\n    var restructured = transform.processJson(jsonData);\n    if (debugMode) {\n      console.log(\"restructured data:\");\n      console.log(JSON.stringify(restructured, null, 2));\n    }\n    return restructured;\n  }\n\n  function getDescriptions() {\n    var descriptions = [];\n    descriptions.push(summarizedAccountNumberDescription());\n    descriptions.push(summarizedAccountNameDescription());\n    descriptions.push(summarizedAccountTypeDescription());\n    \n    descriptions.push(detailsDescription());\n    descriptions.push(filtersDescription());\n\n    descriptions.push(sitesMainDescription());\n    descriptions.push(sitesOptionDefaultUrlPatternDescription());\n    descriptions.push(sitesOptionsSummaryDescription());\n    //descriptions.push(sitesOptionDetailsDescription()); //TODO could add details to filter options\n    descriptions.push(sitesOptionUrlPatternDescription());\n    return descriptions;\n  }\n\n  function summarizedAccountNumberDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"summary\")\n      .category(\"account\") \n      .abbreviation(\"&#x1F4B6;\") //banknote with euro sign\n      .indexStartsWith(\"0.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.accountnumber\")\n      .groupName(\"summaries\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n      .build();\n  }\n\n  function summarizedAccountNameDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"summary\")\n      .category(\"account\") \n      .indexStartsWith(\"0.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.disposer\")\n      .groupName(\"summaries\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n      .build();\n  }\n\n  function summarizedAccountTypeDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"summary\")\n      .category(\"account\") \n      .indexStartsWith(\"0.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.businesstype\")\n      .groupName(\"summaries\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n      .build();\n  }\n\n  function detailsDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"detail\")\n      .category(\"account\")\n      .indexStartsWith(\"0.\")\n      .propertyPatternTemplateMode()\n      .propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n      .groupName(\"details\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--summary--{{index[0]}}--{{index[1]}}\")\n      .build();\n  }\n\n  function filtersDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"filter\")\n      .category(\"account\")\n      .abbreviation(\"&#128206;\") //Paperclip symbol\n      .indexStartsWith(\"1.\")\n      .propertyPatternTemplateMode()\n      .propertyPattern(\"responses.aggregations.{{fieldName}}.buckets.key\")\n      .groupName(\"options\")\n      .groupPattern(\"{{index[0]}}--{{type}}--{{category}}--{{fieldName}}\")\n      .build();\n  }\n\n  function sitesMainDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"main\")\n      .category(\"account\") \n      .abbreviation(\"&#x261c;\") //finger left navigation symbol\n      .indexStartsWith(\"2.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.name\")\n      .displayPropertyName(\"Target\")\n      .groupName(\"default\")\n      .groupPattern(\"{{category}}--{{type}}\")\n      .build();\n  }\n\n  function sitesOptionDefaultUrlPatternDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"url\")\n      .category(\"account\")\n      .indexStartsWith(\"2.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.urltemplate\")\n      .groupName(\"urltemplate\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--main\")\n      .build();\n  }\n\n  function sitesOptionsSummaryDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"summary\")\n      .category(\"account\")\n      .indexStartsWith(\"3.\")\n      .propertyPatternEqualMode()\n      .propertyPattern(\"responses.hits.hits._source.name\")\n      .displayPropertyName(\"Target\")\n      .groupName(\"summaries\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--main\")\n      .groupDestinationName(\"options\")\n      .build();\n  }\n\n  // TODO could add details to filter/navigation options\n  // function sitesOptionDetailsDescription() {\n  //   return new datarestructor.PropertyStructureDescriptionBuilder()\n  //     .type(\"details\")\n  //     .category(\"account\")\n  //     .indexStartsWith(\"3.\")\n  //     .propertyPatternTemplateMode()\n  //     .propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n  //     .groupName(\"details\")\n  //     .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n  //     .groupDestinationPattern(\"{{category}}--summary--{{index[0]}}--{{index[1]}}\")\n  //     .build();\n  // }\n\n  function sitesOptionUrlPatternDescription() {\n    return new datarestructor.PropertyStructureDescriptionBuilder()\n      .type(\"url\")\n      .category(\"account\")\n      .indexStartsWith(\"3.\")\n      .propertyPatternTemplateMode()\n      .propertyPattern(\"responses.hits.hits._source.urltemplate\")\n      .groupName(\"urltemplate\")\n      .groupPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}\")\n      .groupDestinationPattern(\"{{category}}--summary--{{index[0]}}--{{index[1]}}\")\n      .build();\n  }\n\n  return DataConverter;\n}());\n","// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\nparcelRequire = (function (modules, cache, entry, globalName) {\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;\n  var nodeRequire = typeof require === 'function' && require;\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error('Cannot find module \\'' + name + '\\'');\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = cache[name] = new newRequire.Module(name);\n\n      modules[name][0].call(module.exports, localRequire, module, module.exports, this);\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x){\n      return newRequire(localRequire.resolve(x));\n    }\n\n    function resolve(x){\n      return modules[name][1][x] || x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [function (require, module) {\n      module.exports = exports;\n    }, {}];\n  };\n\n  var error;\n  for (var i = 0; i < entry.length; i++) {\n    try {\n      newRequire(entry[i]);\n    } catch (e) {\n      // Save first error but execute all entries\n      if (!error) {\n        error = e;\n      }\n    }\n  }\n\n  if (entry.length) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(entry[entry.length - 1]);\n\n    // CommonJS\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n      module.exports = mainExports;\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n     define(function () {\n       return mainExports;\n     });\n\n    // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n\n  // Override the current require with this new one\n  parcelRequire = newRequire;\n\n  if (error) {\n    // throw error from earlier, _after updating parcelRequire_\n    throw error;\n  }\n\n  return newRequire;\n})({\"kBit\":[function(require,module,exports) {\n\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\n\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\n\nvar internal_object_tools = module.exports = {}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\n\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n\n    if (Object(cur) !== cur) {\n      result.push({\n        name: prop,\n        value: cur\n      });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n\n      if (l === 0) {\n        result[prop] = [];\n        result.push({\n          name: prop,\n          value: \"\"\n        });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n\n      if (isEmpty && prop) {\n        result.push({\n          name: prop,\n          value: \"\"\n        });\n      }\n    }\n  }\n\n  recurse(data, \"\", 0);\n  return result;\n};\n},{}],\"gEHB\":[function(require,module,exports) {\n/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\n\nvar module = templateResolverInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction templateResolverInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */\n\n\nvar template_resolver = module.exports = {}; // Export module for npm...\n\ntemplate_resolver.internalCreateIfNotExists = templateResolverInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\n\ntemplate_resolver.Resolver = function () {\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n  /**\n   * Resolver. Is used inside this repository. It could also be used outside.\n   * @param {*} sourceDataObject The properties of this object will be used to replace the placeholders in the template.\n   * @constructs Resolver\n   * @alias module:template_resolver.Resolver\n   */\n\n  function Resolver(sourceDataObject) {\n    /**\n     * The properties of this source data object will be used to replace the placeholders in the template.\n     */\n    this.sourceDataObject = sourceDataObject;\n    /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */\n\n    this.resolveTemplate = function (template) {\n      return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n    };\n    /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     * @public\n     */\n\n\n    this.resolvableFieldsOfAll = function () {\n      var map = {};\n\n      var ignoreInternalFields = function (propertyName) {\n        return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n      };\n\n      var index;\n\n      for (index = 0; index < arguments.length; index += 1) {\n        addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n      }\n\n      return map;\n    };\n    /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */\n\n\n    this.replaceResolvableFields = function (stringContainingVariables, resolvableFields) {\n      var replaced = stringContainingVariables;\n      var propertyNames = Object.keys(resolvableFields);\n      var propertyIndex = 0;\n      var propertyName = \"\";\n      var propertyValue = \"\";\n\n      for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n        propertyName = propertyNames[propertyIndex];\n        propertyValue = resolvableFields[propertyName];\n        replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n      }\n\n      return replaced;\n    };\n  }\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n\n\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName); // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n      // and a property named \"value\" inside the same sub object (containing its value).\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      // TODO could make \"fieldName\" and \"value\" configurable\n\n      if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n\n    return map;\n  }\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n\n\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n\n    var propertyGroup = \"\";\n\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return {\n      group: propertyGroup,\n      groupWithoutArrayIndices: propertyGroupWithoutArrayIndices,\n      name: propertyName\n    };\n  }\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n\n\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n\n    return mapObject;\n  }\n\n  return Resolver;\n}();\n},{\"../../lib/js/flattenToArray\":\"kBit\"}],\"NvOR\":[function(require,module,exports) {\n/**\n * @file Describes a data field of the restructured data.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\n\nvar module = describedFieldInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction describedFieldInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n/**\n * Describes a data field of the restructured data.\n * @module described_field\n */\n\n\nvar described_field = module.exports = {}; // Export module for npm...\n\ndescribed_field.internalCreateIfNotExists = describedFieldInternalCreateIfNotExists;\n/**\n * Describes a field of the restructured data.\n * Dynamically added properties represent custom named groups containing DescribedDataField-Arrays.\n *\n * @typedef {Object} module:described_field.DescribedDataField\n * @property {string} [category=\"\"] - name of the category. Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [type=\"\"] - type of the data element. Examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as data filters.\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the splitted index. Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4]\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {string} displayName - display name of the field\n * @property {string} fieldName - field name\n * @property {{*}} value - content of the field\n * @property {module:described_field.DescribedDataField[]} [couldBeAnyCustomGroupName] any number of groups attached to the field each containing multiple fields\n */\n\ndescribed_field.DescribedDataFieldBuilder = function () {\n  /**\n   * Builds a {@link module:described_field.DescribedDataField}.\n   * DescribedDataField is the main element of the restructured data and therefore considered \"public\".\n   * @constructs DescribedDataFieldBuilder\n   * @alias module:described_field.DescribedDataFieldBuilder\n   */\n  function DescribedDataFieldBuilder() {\n    /**\n     * @type {module:described_field.DescribedDataField}\n     */\n    this.describedField = {\n      category: \"\",\n      type: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      index: [],\n      groupNames: [],\n      displayName: \"\",\n      fieldName: \"\",\n      value: \"\"\n    };\n    /**\n     * Takes over all values of the template {@link module:described_field.DescribedDataField}.\n     * @function\n     * @param {module:described_field.DescribedDataField} template\n     * @returns {DescribedDataFieldBuilder}\n     * @example fromDescribedDataField(sourceField)\n     */\n\n    this.fromDescribedDataField = function (template) {\n      this.category(template.category);\n      this.type(template.type);\n      this.abbreviation(template.abbreviation);\n      this.image(template.image);\n      this.index(template.index);\n      this.groupNames(template.groupNames);\n      this.displayName(template.displayName);\n      this.fieldName(template.fieldName);\n      this.value(template.value);\n      return this;\n    };\n    /**\n     * Sets the category.\n     *\n     * Contains a short domain nam, for example:\n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example category(\"Product\")\n     */\n\n\n    this.category = function (value) {\n      this.describedField.category = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the type.\n     *\n     * Contains the type of the entry, for example:\n     * - \"summary\" for e.g. a list overview.\n     * - \"detail\" e.g. when a summary is selected.\n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example type(\"summary\")\n     */\n\n\n    this.type = function (value) {\n      this.describedField.type = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     *\n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example abbreviation(\"P\")\n     */\n\n\n    this.abbreviation = function (value) {\n      this.describedField.abbreviation = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example image(\"img/product.png\")\n     */\n\n\n    this.image = function (value) {\n      this.describedField.image = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the index as an array of numbers containing the splitted array indexes of the source field.\n     * Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4].\n     *\n     * @function\n     * @param {number[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example index([2,4])\n     */\n\n\n    this.index = function (value) {\n      this.describedField.index = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the group names as an array of strings containing the names of the dynamically added properties,\n     * that contain an array of {@link module:described_field.DescribedDataField}-Objects.\n     *\n     * @function\n     * @param {string[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example groupNames([\"summaries\",\"details\",\"options\"])\n     */\n\n\n    this.groupNames = function (value) {\n      this.describedField.groupNames = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the display name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example displayName(\"Color\")\n     */\n\n\n    this.displayName = function (value) {\n      this.describedField.displayName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the (technical) field name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example fieldName(\"color\")\n     */\n\n\n    this.fieldName = function (value) {\n      this.describedField.fieldName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the value/content of the field.\n     *\n     * @function\n     * @param {*} value\n     * @returns {DescribedDataFieldBuilder}\n     * @example value(\"darkblue\")\n     */\n\n\n    this.value = function (value) {\n      this.describedField.value = value;\n      return this;\n    };\n    /**\n     * Finalizes the settings and builds the {@link module:described_field.DescribedDataField}.\n     * @function\n     * @returns {module:described_field.DescribedDataField}\n     */\n\n\n    this.build = function () {\n      return this.describedField;\n    };\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value !== null && value !== \"\";\n  }\n\n  function withDefaultString(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function withDefaultArray(value, defaultValue) {\n    return value === undefined || value === null ? defaultValue : value;\n  }\n\n  return DescribedDataFieldBuilder;\n}();\n/**\n * Creates a new described data field with all properties of the original one except for dynamically added groups.\n * @param {module:described_field.DescribedDataField} describedDataField\n * @returns {module:described_field.DescribedDataField}\n * @memberof module:described_field\n */\n\n\ndescribed_field.copyWithoutGroups = function (describedDataField) {\n  return new described_field.DescribedDataFieldBuilder().fromDescribedDataField(describedDataField).groupNames([]).build();\n};\n\ndescribed_field.DescribedDataFieldGroup = function () {\n  /**\n   * Adds groups to {@link module:described_field.DescribedDataField}s. These groups are dynamically added properties\n   * that contain an array of sub fields of the same type {@link module:described_field.DescribedDataField}s.\n   *\n   * @param {module:described_field.DescribedDataField} dataField\n   * @constructs DescribedDataFieldGroup\n   * @alias module:described_field.DescribedDataFieldGroup\n   * @example new described_field.DescribedDataFieldGroup(field).addGroupEntry(\"details\", detailField);\n   */\n  function DescribedDataFieldGroup(dataField) {\n    this.dataField = dataField;\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entry will be added\n     * @param {module:described_field.DescribedDataField} describedField sub field that is added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n\n    this.addGroupEntry = function (groupName, describedField) {\n      this.addGroupEntries(groupName, [describedField]);\n      return this;\n    };\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entries will be added\n     * @param {module:described_field.DescribedDataField[]} describedFields sub fields that are added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n\n\n    this.addGroupEntries = function (groupName, describedFields) {\n      if (!groupName || groupName.length === 0) {\n        return this;\n      }\n\n      if (!describedFields || describedFields.length === 0) {\n        return this;\n      }\n\n      if (this.dataField[groupName] === undefined) {\n        this.dataField.groupNames.push(groupName);\n        this.dataField[groupName] = [];\n      }\n\n      var index;\n      var describedField;\n\n      for (index = 0; index < describedFields.length; index += 1) {\n        describedField = describedFields[index];\n        this.dataField[groupName].push(describedField);\n      }\n\n      return this;\n    };\n  }\n\n  return DescribedDataFieldGroup;\n}();\n},{}],\"hflC\":[function(require,module,exports) {\n/**\n * @file datarestructor transforms parsed JSON objects into a uniform data structure\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n */\n\"use strict\";\n\nvar module = datarestructorInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction datarestructorInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n/**\n * datarestructor namespace and module declaration.\n * It contains all functions to convert an object (e.g. parsed JSON) into uniform enumerated list of described field entries.\n * \n * <b>Transformation steps:</b>\n * - JSON\n * - flatten\n * - mark and identify\n * - add array fields\n * - deduplicate \n * - group\n * - flatten again\n * @module datarestructor\n */\n\n\nvar datarestructor = module.exports = {}; // Export module for npm...\n\ndatarestructor.internalCreateIfNotExists = datarestructorInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\n\nvar template_resolver = template_resolver || require(\"../../src/js/templateResolver\"); // supports vanilla js & npm\n\n\nvar described_field = described_field || require(\"../../src/js/describedfield\"); // supports vanilla js & npm\n\n/**\n * Takes the full qualified original property name and extracts a simple name out of it.\n * \n * @callback module:datarestructor.propertyNameFunction\n * @param {string} propertyName full qualified, point separated property name \n * @return {String} extracted, simple name\n */\n\n/**\n * Describes a selected part of the incoming data structure and defines, \n * how the data should be transformed.\n * \n * @typedef {Object} module:datarestructor.PropertyStructureDescription\n * @property {string} type - \"\"(default). Some examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n * @property {string} category - name of the category. Default = \"\". Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {boolean} propertyPatternTemplateMode - \"false\"(default): property name needs to be equal to the pattern. \"true\" allows variables like \"{{fieldName}}\" inside the pattern.\n * @property {string} propertyPattern - property name pattern (without array indices) to match\n * @property {string} indexStartsWith - \"\"(default) matches all ids. String that needs to match the beginning of the id. E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n * @property {module:datarestructor.propertyNameFunction} getDisplayNameForPropertyName - display name for the property. \"\"(default) last property name element with upper case first letter.\n * @property {module:datarestructor.propertyNameFunction} getFieldNameForPropertyName - field name for the property. \"\" (default) last property name element.\n * @property {string} groupName - name of the property, that contains grouped entries. Default=\"group\".\n * @property {string} groupPattern - Pattern that describes how to group entries. \"groupName\" defines the name of this group. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationPattern - Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationName - (default=groupName) Name of the group when it had been moved to the destination.\n * @property {string} deduplicationPattern - Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n */\n\n\ndatarestructor.PropertyStructureDescriptionBuilder = function () {\n  \"use strict\";\n  /**\n   * Builder for a {@link PropertyStructureDescription}.\n   * @constructs PropertyStructureDescriptionBuilder\n   * @alias module:datarestructor.PropertyStructureDescriptionBuilder\n   */\n\n  function PropertyStructureDescription() {\n    /**\n     * @type {module:datarestructor.PropertyStructureDescription}\n     */\n    this.description = {\n      type: \"\",\n      category: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      propertyPatternTemplateMode: false,\n      propertyPattern: \"\",\n      indexStartsWith: \"\",\n      groupName: \"group\",\n      groupPattern: \"\",\n      groupDestinationPattern: \"\",\n      groupDestinationName: null,\n      deduplicationPattern: \"\",\n      getDisplayNameForPropertyName: null,\n      getFieldNameForPropertyName: null,\n      matchesPropertyName: null\n    };\n    /**\n     * Sets the type.\n     * \n     * Contains the type of the entry, for example: \n     * - \"summary\" for e.g. a list overview. \n     * - \"detail\" e.g. when a summary is selected. \n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example type(\"summary\")\n     */\n\n    this.type = function (value) {\n      this.description.type = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the category.\n     * \n     * Contains a short domain nam, for example: \n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example category(\"Product\")\n     */\n\n\n    this.category = function (value) {\n      this.description.category = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     * \n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example abbreviation(\"P\")\n     */\n\n\n    this.abbreviation = function (value) {\n      this.description.abbreviation = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example image(\"img/product.png\")\n     */\n\n\n    this.image = function (value) {\n      this.description.image = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets \"equal mode\" for the property pattern.\n     * \n     * \"propertyPattern\" need to match exactly if this mode is activated.\n     *  It clears propertyPatternTemplateMode which means \"equal\" mode.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n\n\n    this.propertyPatternEqualMode = function () {\n      this.description.propertyPatternTemplateMode = false;\n      return this;\n    };\n    /**\n     * Sets \"template mode\" for the property pattern.\n     * \n     * \"propertyPattern\" can contain variables like {{fieldName}} and\n     * doesn't need to match the property name exactly. If the \"propertyPattern\"\n     * is shorter than the property name, it also matches when the property name\n     * starts with the \"propertyPattern\".\n     * \n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n\n\n    this.propertyPatternTemplateMode = function () {\n      this.description.propertyPatternTemplateMode = true;\n      return this;\n    };\n    /**\n     * Sets the property name pattern. \n     * \n     * Contains single property names with sub types separated by \".\" without array indices.\n     * May contain variables in double curly brackets.\n     * \n     * Example: \n     * - responses.hits.hits._source.{{fieldName}}\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n     */\n\n\n    this.propertyPattern = function (value) {\n      this.description.propertyPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional beginning of the id that needs to match.\n     * Matches all indices if set to \"\" (or not called).\n     * \n     * For example:\n     * - \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example indexStartsWith(\"1.\")\n     */\n\n\n    this.indexStartsWith = function (value) {\n      this.description.indexStartsWith = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Overrides the display name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name starting with an upper case character.\n     *  \n     * For example:\n     * - \"Product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example displayPropertyName(\"Product\")\n     */\n\n\n    this.displayPropertyName = function (value) {\n      this.description.getDisplayNameForPropertyName = createNameExtractFunction(value, this.description);\n\n      if (isSpecifiedString(value)) {\n        return this;\n      }\n\n      this.description.getDisplayNameForPropertyName = removeArrayValuePropertyPostfixFunction(this.description.getDisplayNameForPropertyName);\n      this.description.getDisplayNameForPropertyName = upperCaseFirstLetterForFunction(this.description.getDisplayNameForPropertyName);\n      return this;\n    };\n    /**\n     * Overrides the (technical) field name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name.\n     *  \n     * For example:\n     * - \"product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example fieldName(\"product\")\n     */\n\n\n    this.fieldName = function (value) {\n      this.description.getFieldNameForPropertyName = createNameExtractFunction(value, this.description);\n      return this;\n    };\n    /**\n     * Sets the name of the property, that contains grouped entries. \n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupName(\"details\")\n     */\n\n\n    this.groupName = function (value) {\n      this.description.groupName = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes how to group entries. \n     * \n     * \"groupName\" defines the name of this group.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupPattern(\"{{type}}-{{category}}\")\n     */\n\n\n    this.groupPattern = function (value) {\n      this.description.groupPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes where the group should be moved to. \n     * \n     * Default=\"\"=Group will not be moved.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"main-{{category}}\")\n     */\n\n\n    this.groupDestinationPattern = function (value) {\n      this.description.groupDestinationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the name of the group when it had been moved to the destination.\n     * \n     * The default value is the groupName, which will be used when the value is not valid (null or empty)\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"options\")\n     */\n\n\n    this.groupDestinationName = function (value) {\n      this.description.groupDestinationName = withDefault(value, this.description.groupName);\n      return this;\n    };\n    /**\n     * Sets the pattern to be used to remove duplicate entries. \n     * \n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n     */\n\n\n    this.deduplicationPattern = function (value) {\n      this.description.deduplicationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Finalizes the settings and builds the  PropertyStructureDescription.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n\n\n    this.build = function () {\n      this.description.matchesPropertyName = createFunctionMatchesPropertyName(this.description);\n\n      if (this.description.getDisplayNameForPropertyName == null) {\n        this.displayPropertyName(\"\");\n      }\n\n      if (this.description.getFieldNameForPropertyName == null) {\n        this.fieldName(\"\");\n      }\n\n      if (this.description.groupDestinationName == null) {\n        this.groupDestinationName(\"\");\n      }\n\n      return this.description;\n    };\n  }\n\n  function createNameExtractFunction(value, description) {\n    if (isSpecifiedString(value)) {\n      return function () {\n        return value;\n      };\n    }\n\n    if (description.propertyPatternTemplateMode) {\n      var patternToMatch = description.propertyPattern; // closure (closed over) parameter\n\n      return extractNameUsingTemplatePattern(patternToMatch);\n    }\n\n    return extractNameUsingRightMostPropertyNameElement();\n  }\n\n  function createFunctionMatchesPropertyName(description) {\n    var propertyPatternToMatch = description.propertyPattern; // closure (closed over) parameter\n\n    if (!isSpecifiedString(propertyPatternToMatch)) {\n      return function () {\n        return false; // Without a propertyPattern, no property will match (deactivated mark/identify).\n      };\n    }\n\n    if (description.propertyPatternTemplateMode) {\n      return function (propertyNameWithoutArrayIndices) {\n        return templateModePatternRegexForPattern(propertyPatternToMatch).exec(propertyNameWithoutArrayIndices) != null;\n      };\n    }\n\n    return function (propertyNameWithoutArrayIndices) {\n      return propertyNameWithoutArrayIndices === propertyPatternToMatch;\n    };\n  }\n\n  function rightMostPropertyNameElement(propertyName) {\n    var regularExpression = new RegExp(\"(\\\\w+)$\", \"gi\");\n    var match = propertyName.match(regularExpression);\n\n    if (match != null) {\n      return match[0];\n    }\n\n    return propertyName;\n  }\n\n  function upperCaseFirstLetter(value) {\n    if (value.length > 1) {\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    }\n\n    return value;\n  }\n\n  function upperCaseFirstLetterForFunction(nameExtractFunction) {\n    return function (propertyName) {\n      return upperCaseFirstLetter(nameExtractFunction(propertyName));\n    };\n  }\n\n  function removeArrayValuePropertyPostfixFunction(nameExtractFunction) {\n    return function (propertyName) {\n      var name = nameExtractFunction(propertyName);\n      name = name != null ? name : \"\";\n      return name.replace(\"_comma_separated_values\", \"\");\n    };\n  }\n\n  function extractNameUsingTemplatePattern(propertyPattern) {\n    return function (propertyName) {\n      var regex = templateModePatternRegexForPatternAndVariable(propertyPattern, \"{{fieldName}}\");\n      var match = regex.exec(propertyName);\n\n      if (match && match[1] != \"\") {\n        return match[1];\n      }\n\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function extractNameUsingRightMostPropertyNameElement() {\n    return function (propertyName) {\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function templateModePatternRegexForPattern(propertyPatternToUse) {\n    var placeholderInDoubleCurlyBracketsRegEx = new RegExp(\"\\\\\\\\\\\\{\\\\\\\\\\\\{[-\\\\w]+\\\\\\\\\\\\}\\\\\\\\\\\\}\", \"gi\");\n    return templateModePatternRegexForPatternAndVariable(propertyPatternToUse, placeholderInDoubleCurlyBracketsRegEx);\n  }\n\n  function templateModePatternRegexForPatternAndVariable(propertyPatternToUse, variablePattern) {\n    var pattern = escapeCharsForRegEx(propertyPatternToUse);\n\n    if (typeof variablePattern === \"string\") {\n      variablePattern = escapeCharsForRegEx(variablePattern);\n    }\n\n    pattern = pattern.replace(variablePattern, \"([-\\\\w]+)\");\n    pattern = \"^\" + pattern;\n    return new RegExp(pattern, \"i\");\n  }\n\n  function escapeCharsForRegEx(characters) {\n    var nonWordCharactersRegEx = new RegExp(\"([^-\\\\w])\", \"gi\");\n    return characters.replace(nonWordCharactersRegEx, \"\\\\$1\");\n  }\n\n  function withDefault(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value != null && value != \"\";\n  }\n\n  return PropertyStructureDescription;\n}();\n/**\n * Adds a group item/entry to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntryFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n */\n\n/**\n * Adds some group items/entries to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntriesFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry[]} describedEntry entries that should be added to the group\n */\n\n/**\n * @typedef {Object} module:datarestructor.DescribedEntry\n * @property {string} category - category of the result from the PropertyStructureDescription using a short name or e.g. a symbol character\n * @property {string} type - type of the result from PropertyStructureDescription\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the split index. Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with the two elements: [2,4]\n * @property {string} displayName - display name extracted from the point separated hierarchical property name, e.g. \"Name\"\n * @property {string} fieldName - field name extracted from the point separated hierarchical property name, e.g. \"name\"\n * @property {string} value - content of the field\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {module:datarestructor.addGroupEntryFunction} addGroupEntry - function, that adds an entry to the given group. If the group does not exist, it will be created.\n * @property {module:datarestructor.addGroupEntriesFunction} addGroupEntries - function, that adds entries to the given group. If the group does not exist, it will be created.\n * @property {boolean} _isMatchingIndex - true, when _identifier.index matches the described \"indexStartsWith\"\n * @property {Object} _identifier - internal structure for identifier. Avoid using it outside since it may change.\n * @property {string} _identifier.index - array indices in hierarchical order separated by points, e.g. \"0.0\"\n * @property {string} _identifier.value - the (single) value of the \"flattened\" property, e.g. \"Smith\"\n * @property {string} _identifier.propertyNameWithArrayIndices - the \"original\" flattened property name in hierarchical order separated by points, e.g. \"responses[0].hits.hits[0]._source.name\"\n * @property {string} _identifier.propertyNameWithoutArrayIndices - same as propertyNamesWithArrayIndices but without array indices, e.g. \"responses.hits.hits._source.name\"\n * @property {string} _identifier.groupId - Contains the resolved groupPattern from the PropertyStructureDescription. Entries with the same id will be grouped into the \"groupName\" of the PropertyStructureDescription.\n * @property {string} _identifier.groupDestinationId - Contains the resolved groupDestinationPattern from the PropertyStructureDescription. Entries with this id will be moved to the given destination group.\n * @property {string} _identifier.deduplicationId - Contains the resolved deduplicationPattern from the PropertyStructureDescription. Entries with the same id will be considered to be a duplicate and hence removed.\n * @property {Object} _description - PropertyStructureDescription for internal use. Avoid using it outside since it may change.\n */\n\n/**\n * Returns a field value of the given {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.stringFieldOfDescribedEntryFunction\n * @param {module:datarestructor.DescribedEntry} entry described entry that contains the field that should be returned\n * @returns {String} field value \n */\n\n\ndatarestructor.DescribedEntryCreator = function () {\n  \"use strict\";\n\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n  /**\n   * Creates a {@link module:datarestructor.DescribedEntry}.\n   * @constructs DescribedEntryCreator\n   * @alias module:datarestructor.DescribedEntryCreator\n   */\n\n  function DescribedEntry(entry, description) {\n    var indices = indicesOf(entry.name);\n    var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n    var templateResolver = new template_resolver.Resolver(this);\n    this.category = description.category;\n    this.type = description.type;\n    this.abbreviation = description.abbreviation;\n    this.image = description.image;\n    /**\n     * Array of numbers containing the split index.\n     * Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with two elements: [2,4]\n     * This is the public version of the internal variable _identifier.index, which contains in contrast all index elements in one point separated string (e.g. \"2.4\").\n     * @type {number[]}\n     */\n\n    this.index = indices.numberArray;\n    this.displayName = description.getDisplayNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.fieldName = description.getFieldNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.value = entry.value;\n    this.groupNames = [];\n    this._isMatchingIndex = indices.pointDelimited.indexOf(description.indexStartsWith) == 0;\n    this._description = description;\n    this._identifier = {\n      index: indices.pointDelimited,\n      propertyNameWithArrayIndices: entry.name,\n      propertyNameWithoutArrayIndices: propertyNameWithoutArrayIndices,\n      groupId: \"\",\n      groupDestinationId: \"\",\n      deduplicationId: \"\"\n    };\n    this._identifier.groupId = templateResolver.replaceResolvableFields(description.groupPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n    this._identifier.groupDestinationId = templateResolver.replaceResolvableFields(description.groupDestinationPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n    this._identifier.deduplicationId = templateResolver.replaceResolvableFields(description.deduplicationPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName name of the group that should be added\n     * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n     */\n\n    this.addGroupEntry = function (groupName, describedEntry) {\n      this.addGroupEntries(groupName, [describedEntry]);\n    };\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName\n     * @param {module:datarestructor.DescribedEntry[]} describedEntries\n     */\n\n\n    this.addGroupEntries = function (groupName, describedEntries) {\n      if (!this[groupName]) {\n        this.groupNames.push(groupName);\n        this[groupName] = [];\n      }\n\n      var index;\n      var describedEntry;\n\n      for (index = 0; index < describedEntries.length; index += 1) {\n        describedEntry = describedEntries[index];\n        this[groupName].push(describedEntry);\n      }\n    };\n  }\n  /**\n   * @typedef {Object} module:datarestructor.ExtractedIndices\n   * @property {string} pointDelimited - bracket indices separated by points\n   * @property {number[]} numberArray as array of numbers\n   */\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {String} fullPropertyName\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n\n\n  function indicesOf(fullPropertyName) {\n    var arrayBracketsRegEx = new RegExp(\"\\\\[(\\\\d+)\\\\]\", \"gi\");\n    return indicesOfWithRegex(fullPropertyName, arrayBracketsRegEx);\n  }\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {string} fullPropertyName\n   * @param {RegExp} regexWithOneNumberGroup\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n\n\n  function indicesOfWithRegex(fullPropertyName, regexWithOneNumberGroup) {\n    var pointDelimited = \"\";\n    var numberArray = [];\n    var match;\n\n    do {\n      match = regexWithOneNumberGroup.exec(fullPropertyName);\n\n      if (match) {\n        if (pointDelimited.length > 0) {\n          pointDelimited += \".\";\n        }\n\n        pointDelimited += match[1];\n        numberArray.push(parseInt(match[1]));\n      }\n    } while (match);\n\n    return {\n      pointDelimited: pointDelimited,\n      numberArray: numberArray\n    };\n  }\n\n  return DescribedEntry;\n}();\n/**\n * @typedef {Object} module:datarestructor.TransformConfig\n * @property {boolean} debugMode enables/disables detailed logging\n * @property {number} [maxRecursionDepth=8] Maximum recursion depth\n * @property {number} [removeDuplicationAboveRecursionDepth=1]  Duplications will be removed above the given recursion depth value and remain unchanged below it.\n */\n\n\ndatarestructor.Transform = function () {\n  \"use strict\";\n  /**\n   * Main class for the data transformation.\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions\n   * @constructs Transform\n   * @alias module:datarestructor.Transform\n   */\n\n  function Transform(descriptions) {\n    /**\n     * Descriptions of the input data that define the behaviour of the transformation.\n     * @type {module:datarestructor.DescribedEntry[]}\n     */\n    this.descriptions = descriptions;\n    /**\n     * Configuration for the transformation.\n     * @protected\n     * @type {module:datarestructor.TransformConfig}\n     */\n\n    this.config = {\n      /**\n       * Debug mode switch, that enables/disables detailed logging.\n       * @protected\n       * @type {boolean}\n       */\n      debugMode: false,\n\n      /**\n       * Maximum recursion depth. Defaults to 8.\n       * @protected\n       * @type {number}\n       */\n      maxRecursionDepth: 8,\n\n      /**\n       * Duplications will be removed above the given recursion depth and remain below it.\n       * Defaults to 1.\n       *\n       * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n       * data structures are possible by nature and will lead to duplications. Some of them\n       * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n       * To restrict duplications and improve performance it is beneficial to define a\n       * recursion depth, above which further duplication won't be used and should be removed/avoided.\n       *\n       * @protected\n       * @type {number}\n       */\n      removeDuplicationAboveRecursionDepth: 1\n    };\n    /**\n     * Enables debug mode. Logs additional information.\n     * @returns {module:datarestructor.Transform}\n     */\n\n    this.enableDebugMode = function () {\n      this.config.debugMode = true;\n      return this;\n    };\n    /**\n     * Sets the maximum recursion depth. Defaults to 8 if not set.\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */\n\n\n    this.setMaxRecursionDepth = function (value) {\n      if (typeof value !== \"number\" || value < 0) {\n        throw \"Invalid max recursion depth value: \" + value;\n      }\n\n      this.config.maxRecursionDepth = value;\n      return this;\n    };\n    /**\n     * Sets the recursion depth above which duplication will be removed. Duplications below it remain unchanged.\n     * Defaults to 1.\n     *\n     * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n     * data structures are possible by nature and will lead to duplications. Some of them\n     * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n     * To restrict duplications and improve performance it is beneficial to define a\n     * recursion depth, above which further duplication won't be used and should be removed/avoided.\n     *\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */\n\n\n    this.setRemoveDuplicationAboveRecursionDepth = function (value) {\n      if (typeof value !== \"number\" || value < 0) {\n        throw \"Invalid remove duplications above recursion depth value: \" + value;\n      }\n\n      this.config.removeDuplicationAboveRecursionDepth = value;\n      return this;\n    };\n    /**\n     * \"Assembly line\", that takes the (pared JSON) data and processes it using all given descriptions in their given order.\n     * @param {object} data - parsed JSON data or any other data object\n     * @returns {module:datarestructor.DescribedEntry[]}\n     * @example\n     * var allDescriptions = [];\n     * allDescriptions.push(summariesDescription());\n     * allDescriptions.push(detailsDescription());\n     * var result = new datarestructor.Transform(allDescriptions).processJson(jsonData);\n     */\n\n\n    this.processJson = function (data) {\n      return processJsonUsingDescriptions(data, this.descriptions, this.config);\n    };\n  }\n  /**\n   * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n   * @param {object} jsonData parsed JSON data or any other data object\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function processJsonUsingDescriptions(jsonData, descriptions, config) {\n    // \"Flatten\" the hierarchical input json to an array of property names (point separated \"folders\") and values.\n    var processedData = internal_object_tools.flattenToArray(jsonData); // Fill in properties ending with the name \"_comma_separated_values\" for array values to make it easier to display them.\n\n    processedData = fillInArrayValues(processedData);\n\n    if (config.debugMode) {\n      console.log(\"flattened data with array values:\");\n      console.log(processedData);\n    } // Mark, identify and harmonize the flattened data by applying one description after another in their given order.\n\n\n    var describedData = [];\n    var descriptionIndex, description, dataWithDescription;\n\n    for (descriptionIndex = 0; descriptionIndex < descriptions.length; descriptionIndex += 1) {\n      description = descriptions[descriptionIndex]; // Filter all entries that match the current description and enrich them with it\n\n      dataWithDescription = extractEntriesByDescription(processedData, description); // Remove duplicate entries where a deduplicationPattern is described\n\n      describedData = deduplicateFlattenedData(describedData, dataWithDescription);\n    }\n\n    processedData = describedData;\n\n    if (config.debugMode) {\n      console.log(\"describedData data:\");\n      console.log(processedData);\n    } // Group entries where a groupPattern is described\n\n\n    processedData = groupFlattenedData(processedData);\n\n    if (config.debugMode) {\n      console.log(\"grouped describedData data:\");\n      console.log(processedData);\n    } // Move group entries where a groupDestinationPattern is described\n\n\n    processedData = applyGroupDestinationPattern(processedData);\n\n    if (config.debugMode) {\n      console.log(\"moved grouped describedData data:\");\n      console.log(processedData);\n    } // Turns the grouped object back into an array of DescribedEntry-Objects\n\n\n    processedData = propertiesAsArray(processedData); // Converts the internal described entries  into described fields\n\n    processedData = toDescribedFields(processedData, config);\n\n    if (config.debugMode) {\n      console.log(\"transformed result:\");\n      console.log(processedData);\n    }\n\n    return processedData;\n  }\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries that occur later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * The id is extracted from every element using the given function.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function mergeFlattenedData(entries, entriesToMerge, idOfElementFunction) {\n    var entriesToMergeById = asIdBasedObject(entriesToMerge, idOfElementFunction);\n    var merged = [];\n    var index, entry, id;\n\n    for (index = 0; index < entries.length; index += 1) {\n      entry = entries[index];\n      id = idOfElementFunction(entry);\n\n      if (id == null || id === \"\" || entriesToMergeById[id] == null) {\n        merged.push(entry);\n      }\n    }\n\n    for (index = 0; index < entriesToMerge.length; index += 1) {\n      entry = entriesToMerge[index];\n      merged.push(entry);\n    }\n\n    return merged;\n  }\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries occurring later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * \"entriesToMerge\" will be returned directly, if \"entries\" is null or empty.\n   *\n   * The id is extracted from every element using their deduplication pattern (if available).\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @see mergeFlattenedData\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function deduplicateFlattenedData(entries, entriesToMerge) {\n    if (entries == null || entries.length == 0) {\n      return entriesToMerge;\n    }\n\n    var idOfElementFunction = function (entry) {\n      return entry._identifier.deduplicationId;\n    };\n\n    return mergeFlattenedData(entries, entriesToMerge, idOfElementFunction);\n  }\n  /**\n   * Converts the given elements to an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1.\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function asIdBasedObject(elements, idOfElementFunction) {\n    var idIndexedObject = new Object();\n\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      idIndexedObject[idOfElementFunction(element)] = element;\n    }\n\n    return idIndexedObject;\n  }\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id (determined by the entry's groupPattern).\n   * For example, [{id: A, value: 1}] becomes result['A'] = 1.\n   *\n   * Furthermore, this function creates a group property (determined by the entry's groupName)\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function groupFlattenedData(flattenedData) {\n    return groupById(flattenedData, function (entry) {\n      return entry._identifier.groupId;\n    }, function (entry) {\n      return entry._description.groupName;\n    });\n  }\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1. Furthermore, this function creates a group property (with the name )\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupNameOfElementFunction function, that returns the name of the group property that will be created inside the \"main\" element.\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupIdOfElementFunction returns the group id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function groupById(elements, groupIdOfElementFunction, groupNameOfElementFunction) {\n    var groupedResult = new Object();\n\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      var groupId = groupIdOfElementFunction(element);\n\n      if (groupId === \"\") {\n        continue;\n      }\n\n      var groupName = groupNameOfElementFunction(element);\n\n      if (groupName == null || groupName === \"\") {\n        continue;\n      }\n\n      if (!groupedResult[groupId]) {\n        groupedResult[groupId] = element;\n      }\n\n      groupedResult[groupId].addGroupEntry(groupName, element);\n    }\n\n    return groupedResult;\n  }\n  /**\n   * Extracts entries out of \"flattened\" JSON data and provides an array of objects.\n   * @param {Object[]} flattenedData - flattened json from search query result\n   * @param {string} flattenedData[].name - name of the property in hierarchical order separated by points\n   * @param {string} flattenedData[].value - value of the property as string\n   * @param {module:datarestructor.PropertyStructureDescription} - description of structure of the entries that should be extracted\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function extractEntriesByDescription(flattenedData, description) {\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    var filtered = [];\n    flattenedData.filter(function (entry) {\n      var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n\n      if (description.matchesPropertyName(propertyNameWithoutArrayIndices)) {\n        var describedEntry = new datarestructor.DescribedEntryCreator(entry, description);\n\n        if (describedEntry._isMatchingIndex) {\n          filtered.push(describedEntry);\n        }\n      }\n    });\n    return filtered;\n  }\n  /**\n   * Takes already grouped {@link module:datarestructor.DescribedEntry} objects and\n   * uses their \"_identifier.groupDestinationId\" (if exists)\n   * to move groups to the given destination.\n   *\n   * This is useful, if separately described groups like \"summary\" and \"detail\" should be put together,\n   * so that every summery contains a group with the regarding details.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} groupedObject - already grouped entries\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function applyGroupDestinationPattern(groupedObject) {\n    var keys = Object.keys(groupedObject);\n    var keysToDelete = [];\n\n    for (var index = 0; index < keys.length; index++) {\n      var key = keys[index];\n      var entry = groupedObject[key];\n\n      if (entry._description.groupDestinationPattern != \"\") {\n        var destinationKey = entry._identifier.groupDestinationId;\n\n        if (groupedObject[destinationKey] != null) {\n          var newGroup = entry[entry._description.groupName];\n          groupedObject[destinationKey].addGroupEntries(entry._description.groupDestinationName, newGroup);\n          keysToDelete.push(key);\n        }\n      }\n    } // delete all moved entries that had been collected by their key\n\n\n    for (index = 0; index < keysToDelete.length; index += 1) {\n      var keyToDelete = keysToDelete[index];\n      delete groupedObject[keyToDelete];\n    }\n\n    return groupedObject;\n  }\n  /**\n   * Fills in extra \"_comma_separated_values\" properties into the flattened data\n   * for properties that end with an array. E.g. response.hits.hits.tags[0]=\"active\" and response.hits.hits.tags[0]=\"ready\"\n   * will lead to the extra element \"response.hits.hits.tags_comma_separated_values=\"active, ready\".\n   *\n   * @return flattened data with filled in \"_comma_separated_values\" properties\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function fillInArrayValues(flattenedData) {\n    var trailingArrayIndexRegEx = new RegExp(\"\\\\[\\\\d+\\\\]$\", \"gi\");\n    var result = [];\n    var lastArrayProperty = \"\";\n    var lastArrayPropertyValue = \"\";\n    flattenedData.filter(function (entry) {\n      if (!entry.name.match(trailingArrayIndexRegEx)) {\n        if (lastArrayProperty !== \"\") {\n          result.push({\n            name: lastArrayProperty + \"_comma_separated_values\",\n            value: lastArrayPropertyValue\n          });\n          lastArrayProperty = \"\";\n        }\n\n        result.push(entry);\n        return;\n      }\n\n      var propertyNameWithoutTrailingArrayIndex = entry.name.replace(trailingArrayIndexRegEx, \"\");\n\n      if (lastArrayProperty === propertyNameWithoutTrailingArrayIndex) {\n        lastArrayPropertyValue += \", \" + entry.value;\n      } else {\n        if (lastArrayProperty !== \"\") {\n          result.push({\n            name: lastArrayProperty + \"_comma_separated_values\",\n            value: lastArrayPropertyValue\n          });\n          lastArrayProperty = \"\";\n        }\n\n        lastArrayProperty = propertyNameWithoutTrailingArrayIndex;\n        lastArrayPropertyValue = entry.value;\n      }\n\n      result.push(entry);\n    });\n    return result;\n  }\n\n  function propertiesAsArray(groupedData) {\n    var result = [];\n    var propertyNames = Object.keys(groupedData);\n\n    for (var propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex++) {\n      var propertyName = propertyNames[propertyIndex];\n      var propertyValue = groupedData[propertyName];\n      result.push(propertyValue);\n    }\n\n    return result;\n  }\n  /**\n   * Converts described entries (internal data structure) to described fields (external data structure).\n   * Since the structure of a described field is hierarchical, every field needs to be converted\n   * in a recursive manner. The maximum recursion depth is taken as the second parameter.\n   * @param {module:datarestructor.DescribedEntry[]} describedEntries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:described_field.DescribedDataField[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function toDescribedFields(describedEntries, config) {\n    var result = [];\n    var index;\n    var describedEntity;\n\n    for (index = 0; index < describedEntries.length; index += 1) {\n      describedEntity = describedEntries[index];\n      result.push(toDescribedField(describedEntity, 0, config));\n    }\n\n    return result;\n  }\n  /**\n   * Converts a internal described entry to a newly created public described field.\n   * Since the structure of a described field is hierarchical, this function is called recursively.\n   * Because the internal described entries may very likely contain cyclic references, the depth of recursion\n   * needs to be limited. Therefore, the current recursion depth is taken as second parameter\n   * and the maximum recursion depth is taken as third parameter.\n   * @param {module:datarestructor.DescribedEntry} entry the internal entry that will be converted\n   * @param {number} recursionDepth current hierarchy recursion depth\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:described_field.DescribedDataField}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function toDescribedField(entry, recursionDepth, config) {\n    var field = new described_field.DescribedDataFieldBuilder().category(entry.category).type(entry.type).abbreviation(entry.abbreviation).image(entry.image).index(entry.index).displayName(entry.displayName).fieldName(entry.fieldName).value(entry.value).build();\n\n    if (recursionDepth > config.maxRecursionDepth) {\n      return field;\n    }\n\n    var fieldGroups = new described_field.DescribedDataFieldGroup(field);\n    forEachGroupEntry(entry, function (groupName, groupEntry) {\n      if (groupEntry != entry || recursionDepth <= config.removeDuplicationAboveRecursionDepth) {\n        fieldGroups.addGroupEntry(groupName, toDescribedField(groupEntry, recursionDepth + 1, config));\n      } else {\n        if (config.debugMode) {\n          console.log(\"Removed duplicate field \" + groupEntry.fieldName + \" with value \" + groupEntry.value + \" of group \" + groupName + \" at recursion depth \" + recursionDepth);\n        }\n      }\n    });\n    return field;\n  }\n  /**\n   * Takes the full qualified original property name and extracts a simple name out of it.\n   *\n   * @callback module:datarestructor.onEntryFoundFunction\n   * @param {string} groupName name of the group where the entry had been found.\n   * @param {module:datarestructor.DescribedEntry} foundEntry the found entry itself.\n   */\n\n  /**\n   * Traverses through all groups and their entries and calls the given function on every found entry\n   * with the group name and the entry itself as parameters.\n   * @param {module:datarestructor.DescribedEntry} rootEntry\n   * @param {module:datarestructor.onEntryFoundFunction} onFoundEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n\n\n  function forEachGroupEntry(rootEntry, onFoundEntry) {\n    var groupIndex, entryIndex;\n    var groupName, entry;\n\n    for (groupIndex = 0; groupIndex < rootEntry.groupNames.length; groupIndex += 1) {\n      groupName = rootEntry.groupNames[groupIndex];\n\n      for (entryIndex = 0; entryIndex < rootEntry[groupName].length; entryIndex += 1) {\n        entry = rootEntry[groupName][entryIndex];\n        onFoundEntry(groupName, entry);\n      }\n    }\n  }\n\n  return Transform;\n}();\n/**\n * Main fassade for the data restructor as static function(s).\n * \n * @example \n * var allDescriptions = [];\n * allDescriptions.push(summariesDescription());\n * allDescriptions.push(detailsDescription());\n * var result = datarestructor.Restructor.processJsonUsingDescriptions(jsonData, allDescriptions);\n * @namespace module:datarestructor.Restructor\n */\n\n\ndatarestructor.Restructor = {};\n/**\n * Static fassade function for the \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n * @param {object} jsonData - parsed JSON data or any other data object\n * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n * @returns {module:datarestructor.DescribedEntry[]}\n * @memberof module:datarestructor.Restructor\n * @deprecated since v3.1.0, please use \"new datarestructor.Transform(descriptions).processJson(jsonData)\".\n */\n\ndatarestructor.Restructor.processJsonUsingDescriptions = function (jsonData, descriptions, debugMode) {\n  var restructor = new datarestructor.Transform(descriptions);\n\n  if (debugMode) {\n    restructor.enableDebugMode();\n  }\n\n  return restructor.processJson(jsonData);\n};\n},{\"../../lib/js/flattenToArray\":\"kBit\",\"../../src/js/templateResolver\":\"gEHB\",\"../../src/js/describedfield\":\"NvOR\"}]},{},[\"hflC\"], \"data_restructor_js\")"],"names":["$0d6a4c43af361229567048135f77b56e$var$module","$0d6a4c43af361229567048135f77b56e$var$datarestructorInternalCreateIfNotExists","objectToCheck","$0d6a4c43af361229567048135f77b56e$var$restruct","exports","internalCreateIfNotExists","parcelRequire","modules","cache","entry","globalName","previousRequire","nodeRequire","require","name","jumped","currentRequire","err","Error","code","localRequire","resolve","module","newRequire","Module","call","x","moduleName","id","bundle","isParcelRequire","parent","register","error","i","length","e","mainExports","$4b4ac60d2c65cf4f1893cebd12938841$var$define","amd","internal_object_tools","flattenToArray","data","maxRecursionDepth","result","cur","prop","depth","Object","push","value","Array","isArray","l","recurse","isEmpty","p","templateResolverInternalCreateIfNotExists","template_resolver","Resolver","removeArrayBracketsRegEx","RegExp","sourceDataObject","resolveTemplate","template","replaceResolvableFields","addFieldsPerGroup","resolvableFieldsOfAll","map","ignoreInternalFields","propertyName","indexOf","index","arguments","addToFilteredMapObject","stringContainingVariables","resolvableFields","replaced","propertyNames","keys","propertyIndex","propertyValue","replace","fullPropertyName","propertyInfo","getPropertyNameInfos","groupWithoutArrayIndices","group","positionOfRightMostSeparator","lastIndexOf","substr","propertyGroup","propertyGroupWithoutArrayIndices","elements","mapObject","filterMatchesFunction","element","describedFieldInternalCreateIfNotExists","described_field","DescribedDataFieldBuilder","describedField","category","type","abbreviation","image","groupNames","displayName","fieldName","fromDescribedDataField","withDefaultString","withDefaultArray","build","defaultValue","isSpecifiedString","undefined","copyWithoutGroups","describedDataField","DescribedDataFieldGroup","dataField","addGroupEntry","groupName","addGroupEntries","describedFields","datarestructorInternalCreateIfNotExists","datarestructor","PropertyStructureDescriptionBuilder","description","propertyPatternTemplateMode","propertyPattern","indexStartsWith","groupPattern","groupDestinationPattern","groupDestinationName","deduplicationPattern","getDisplayNameForPropertyName","getFieldNameForPropertyName","matchesPropertyName","withDefault","propertyPatternEqualMode","displayPropertyName","createNameExtractFunction","removeArrayValuePropertyPostfixFunction","upperCaseFirstLetterForFunction","createFunctionMatchesPropertyName","patternToMatch","extractNameUsingTemplatePattern","extractNameUsingRightMostPropertyNameElement","propertyPatternToMatch","propertyNameWithoutArrayIndices","templateModePatternRegexForPattern","exec","regularExpression","match","charAt","toUpperCase","slice","nameExtractFunction","upperCaseFirstLetter","regex","templateModePatternRegexForPatternAndVariable","rightMostPropertyNameElement","propertyPatternToUse","placeholderInDoubleCurlyBracketsRegEx","variablePattern","pattern","escapeCharsForRegEx","characters","nonWordCharactersRegEx","PropertyStructureDescription","DescribedEntryCreator","indices","indicesOf","templateResolver","numberArray","_isMatchingIndex","pointDelimited","_description","_identifier","propertyNameWithArrayIndices","groupId","groupDestinationId","deduplicationId","describedEntry","describedEntries","arrayBracketsRegEx","indicesOfWithRegex","regexWithOneNumberGroup","parseInt","DescribedEntry","Transform","descriptions","config","debugMode","removeDuplicationAboveRecursionDepth","enableDebugMode","setMaxRecursionDepth","setRemoveDuplicationAboveRecursionDepth","processJson","processJsonUsingDescriptions","jsonData","processedData","fillInArrayValues","console","log","describedData","descriptionIndex","dataWithDescription","extractEntriesByDescription","deduplicateFlattenedData","groupFlattenedData","applyGroupDestinationPattern","propertiesAsArray","toDescribedFields","entries","entriesToMerge","idOfElementFunction","entriesToMergeById","asIdBasedObject","merged","mergeFlattenedData","idIndexedObject","flattenedData","groupById","groupIdOfElementFunction","groupNameOfElementFunction","groupedResult","filtered","filter","groupedObject","keysToDelete","key","destinationKey","newGroup","keyToDelete","trailingArrayIndexRegEx","lastArrayProperty","lastArrayPropertyValue","propertyNameWithoutTrailingArrayIndex","groupedData","describedEntity","toDescribedField","recursionDepth","field","fieldGroups","forEachGroupEntry","groupEntry","rootEntry","onFoundEntry","groupIndex","entryIndex","Restructor","restructor","$0d6a4c43af361229567048135f77b56e$var$datarestructor","DataConverter","createDataConverter","restructJson","getDescriptions","transform","restructured","JSON","stringify","summarizedAccountNumberDescription","summarizedAccountNameDescription","summarizedAccountTypeDescription","detailsDescription","filtersDescription","sitesMainDescription","sitesOptionDefaultUrlPatternDescription","sitesOptionsSummaryDescription","sitesOptionUrlPatternDescription"],"version":3,"file":"restruct-data-client.js.map"}